1. Linux网络模型（5种）
   
   1. 阻塞I/O模型:最常用的I/O模型就是阻塞I/O模型,缺省情形下,所有文件操作都是阻塞的。我们以套接字接口为例来讲解此模型:在进程空间中调用 recvfrom,其系统调用直到数据包到达且被复制到应用进程的缓冲区中或者发生错误时才返回,在此期间直会等待,进程在从调用 recvfrom开始到它返回的整段时间内都是被阻塞的,因此被称为阻塞I/O模型,如图1-1所示。
   2. 非阻塞I/O模型: recvfrom从应用层到内核的时候,如果该缓冲区没有数据的话,就直接返回一个 EWOULDBLOCK错误,一般都对非阻塞IO模型进行轮询检查这个状态,看内核是不是有数据到来,如图1-2所示。
   3. I/O复用模型: Linux提供 select/poll,进程通过将一个或多个fd传递给 select或poll系统调用,阻塞在 select操作上,这样 select/poll可以帮我们侦测多个fd是否处于就绪状态。 select/poll是顺序扫描fd是否就绪,而且支持的fd数量有限,因此它的使用受到了一些制约。 Linux还提供了一个epoll系统调用, epoll使用基于事件驱动方式代替顺序扫描,因此性能更高。当有fd就绪时,立即回调函数 rollback,如图1-3所示。
   4. 信号驱动I/O模型:首先开启套接口信号驱动I/O功能,并通过系统调用 sigaction执行一个信号处理函数(此系统调用立即返回,进程继续工作,它是非阻塞的)。当数据准备就绪时,就为该进程生成一个 SIGIO信号,通过信号回调通知应用程序调用 recvfrom来读取数据,并通知主循环函数处理数据,如图1-4所示。
   5. 异步I/O:告知内核启动某个操作,并让内核在整个操作完成后(包括将数据从内核复制到用户自己的缓冲区)通知我们。这种模型与信号驱动模型的主要区别是:信号驱动I/O由内核通知我们何时可以开始一个I/O操作;异步I/O模型由内核通知我们I/O操作何时已经完成,如图1-5所示。


2. redis的备份与回收
   
   Redis的备份：
   
   1. 一种是"RDB"。是快照(snapshotting)，它是备份当前瞬间Redis在内存中的数据记录;
   2. 另一种是"AOF"。只追加文件(Append-Only File,AOF)，其作用是当Redis执行写命令后，在一定的条件下将执行过的写命令依次保存在Redis的文件中，将来就可以依次执行那些保存的命令恢复Redis的数据。
    
   对于快照备份而言，如果当前Redis数据量大，备份可能会造成卡顿，但是恢复重启比较快速。对于AOF备份，则相反。
   
   Redis内存回收策略：6种
   
   1. volatile-lru ：采用LRU算法(最近最少使用算法)，但是只淘汰超时的键值对。
   2. allkeys-lru ：采用LRU算法，淘汰键值对。
   3. volatile-random :采用随机淘汰策略，但是只淘汰超时的键值对。
   4. allkeys-random :采用随机淘汰策略，淘汰键值对。
   5. volatile-ttl  ：采用TTL算法(生存周期)，淘汰存活时间最短的键值对。
   6. noeviction ：不淘汰任何键值对，内存已满时，进行写操作返回错误。

3.     
   

   
##### redis
1. redis是什么？哪些使用场景
   c语言编写的高速缓存数据库，使用场景：微博。。。
2. redis支持的数据类型
   String （微博数，粉丝数）,list（粉丝列表）,hash（个人信息）,set（共同粉丝）,zset（礼物榜）
3. redis和memcached的区别
   redis支持更丰富的数据类型，memcached只支持string；持久化；集群模式；Memcached是多线程，非阻塞IO复用的网络模型;Redis使用单线程的多路 IO 复用模型
4. 为什么使用redis
   高性能：直接操作内存，同步缓存即可  ；高并发：直接操作缓存，能承受的请求量远大于直接访问数据库
5. 为什么用redis不用map/guava做缓存
   map/guava是本地缓存，轻量快速，生命周期随jvm销毁而结束,多实例各自保存缓存，有不一致性；redis分布式缓存，一致性，高可用
6. redis设置过期时间
   expire time
7. 过期删除策略
   定期删除+惰性删除；定期删除:100ms随机抽取设置了过期时间的key检查，过期就删除 ；惰性删除：使用这个key的时候检查，过期则删除
8. 仅设置过期时间会漏掉好多key,会导致redis内存耗尽，怎么解决? redis内存淘汰策略（6种）
   1. volatile-lru:从已设置过期时间的数据集(server.db[i].expires)中挑选最近最少使用的数据淘汰
   2. volatile-ttl:从已设置过期时间的数据集(server.db[i].expires)中挑选将要过期的数据淘汰
   3. volatile-random:从已设置过期时间的数据集(server.db[i].expires)中任意选择数据淘汰
   4. allkeys-lru:当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key(这个是最常用的).
   5. allkeys-random:从数据集(server.db[i].dict)中任意选择数据淘汰
   6. no-eviction:禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。
9. redis持久化（2种）
   1. RDB（snapshotting) 快照 ，默认 ，数据在某个时间点上的副本  save 900 1 在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照
   2. AOF（append-only file）只追加文件，执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件，appendonly yes 命令
      + appendfsync always #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度
      + appendfsync everysec #每秒钟同步一次，显示地将多个写命令同步到硬盘
      + appendfsync no #让操作系统决定何时进行同步
    redis 4.0支持RDB和AOF的混合持久化，通过配置项 aof-use-rdb-preamble 开启

    如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。
10. AOF重写

    AOF重写可以产生一个新的AOF文件，这个新的AOF文件和原有的AOF文件所保存的数据库状态一样，但体积更小。

    在执行 BGREWRITEAOF 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新AOF文件期 间，记录服务器执行的所有写命令。当子进程完成创建新AOF文件的工作之后，服务器会将重写缓冲区中的所有内容 追加到新AOF文件的末尾，使得新旧两个AOF文件所保存的数据库状态一致。最后，服务器用新的AOF文件替换旧的 AOF文件，以此来完成AOF文件重写操作

11. redis事务

    Redis 通过 MULTI、EXEC、WATCH 等命令来实现事务(transaction)功能。事务提供了一种将多个命令请求打包，然 后一次性、按顺序地执行多个命令的机制，并且在事务执行期间，服务器不会中断事务而改去执行其他客户端的命令 请求，它会将事务中的所有命令都执行完毕，然后才去处理其他客户端的命令请求。
    在传统的关系式数据库中，常常用 ACID 性质来检验事务功能的可靠性和安全性。在 Redis 中，事务总是具有原子性 (Atomicity)、一致性(Consistency)和隔离性(Isolation)，并且当 Redis 运行在某种特定的持久化模式下时，事务 也具有持久性(Durability)。

12. redis为什么单线程还这么快

    + redis是操作内存，不受磁盘io速度限制，速度快，大缓存cpu不是redis的瓶颈，只有内存和网络带宽影响。
    + 单线程容易实现，没有线程上下文切换带来的消耗
    + 数据结构专门设计，操作简单
    + I/O多路复用，非阻塞io。多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），
      并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗）
13. 缓存雪崩
    缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。

    处理：
    + 事前:尽量保证整个 redis 集群的高可用性，发现机器宕机尽快补上。选择合适的内存淘汰策略。
    + 事中:本地ehcache缓存 + hystrix限流&降级，避免MySQL崩掉
    + 事后:利用 redis 持久化机制保存的数据尽快恢复缓存

    解决：
    + 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。
    + 如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。
    + 设置热点数据永远不过期。
14. 缓存穿透

    一般是黑客故意去请求缓存中不存在的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。

    解决：
    + 如果一个查询返回的数据为空(不管是数 据不存 在，还是系统故障)，我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。
    + 布隆过滤器
15. 布隆过滤器

    特点：是一个bit向量或者bit数组。高效的插入和查询，告诉某样东西一定不存在或者可能存在，不能删除

    实现：将一个值使用多个不同的hash函数生成多个hash值，并对每个生成的hash值指向的bit设置为1，如果新来的值，对应的bit有一位为0，则该值一定不存在,如果对应的bit位都为1，则可能存在

16. redis数据结构如何专门设计的（六种基础数据结构：动态字符串，链表，字典，跳跃表，整数集合和压缩列表。）

    1. 动态字符串SDS结构
       + len：字符串的真正长度(不包含最后的NULL结束符在内)
       + alloc: 字符串的最大容量(不包含最后的NULL结束符在内)
       + flags：总是一个字节，最低的3bit表示header的类型
       + buf：字符数组

       可以减少修改字符串带来的内存重分配的次数，这依赖于内存预分配和惰性空间释放两大机制

       内存预分配机制













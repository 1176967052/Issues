
#### 时间复杂度
1. 定义
   算法需要执行的运算次数 用 输入大小n 的函数 表示，即 T(n) 。存在常数 c 和函数 f(N)，使得当 N >= c 时 T(N) <= f(N)，表示为 T(n) = O(f(n)) 。
2. 那么当我们拿到算法的执行次数函数 T(n) 之后怎么得到算法的时间复杂度呢？
   1. 常数项对函数的增长速度影响并不大。所以当 T(n) = c，c 为一个常数的时候，我们说这个算法的时间复杂度为 O(1)；如果 T(n) 不等于一个常数项时，直接将常数项省略。
      ```
      比如
      第一个 Hello, World 的例子中 T(n) = 2，所以我们说那个函数(算法)的时间复杂度为 O(1)。
      T(n) = n + 29，此时时间复杂度为 O(n)。
      ```
      
   2. 高次项对于函数的增长速度的影响是最大的。n^3 的增长速度是远超 n^2 的，同时 n^2 的增长速度是远超 n 的。 同时因为要求的精度不高，所以我们直接忽略低此项。    
      ```
      比如
      T(n) = n^3 + n^2 + 29，此时时间复杂度为 O(n^3)。
      ```
   3. 因为函数的阶数对函数的增长速度的影响是最显著的，所以我们忽略与最高阶相乘的常数。
      
      ```
      比如
      T(n) = 3n^3，此时时间复杂度为 O(n^3)。
      ```   
3. 时间复杂度耗费时间对比
   
   O(1) < O(logn) < (n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)      

#### 算法思想
1. 总结的思想
   
   + 两个指针向中间移动
   + 快慢指针，适合获取第几个数，快指针先走n步，慢指针再走
   + 递归
   + 二分法
   + 二进制把一个整数减去１再和原整数与，就会把整数最右边一个１变成０
   + 反转相关可以用栈stack
   + 字符串替换用StringBuilder或者StringBuffer
   + 反转链表只需要吧链表相邻两个节点的指向交换
   
#### 数据结构
1. 随机存取、顺序存取、随机存储和顺序存储

   存取结构：分为随机存取和非随机存取（又称顺序存取）：
   
   1. 随机存取就是直接存取，可以通过下标直接访问的那种数据结构，与存储位置无关，例如数组。非随机存取就是顺序存取了，不能通过下标访问了，只能按照存储顺序存取，与存储位置有关，例如链表。
   2. 顺序存取就是存取第N个数据时，必须先访问前（N-1）个数据 （list），随机存取就是存取第N个数据时，不需要访问前（N-1）个数据，直接就可以对第N个数据操作 （array）。
   
   存储结构：分为顺序存储和随机存储：
    
   1. 顺序存储结构，在计算机中用一组地址连续的存储单元依次存储线性表的各个数据元素，称作线性表的顺序存储结构。顺序存储结构的主要优点是节省存储空间。采用这种方法时，可实现对结点的随机存取，即每一个结点对应一个序号，
      由该序号可以直接计算出来结点的存储地址。但顺序存储方法的主要缺点是不便于修改，对结点的插入、删除运算时，可能要移动一系列的结点。
   2. 随机存储结构，在计算机中用一组任意的存储单元存储线性表的数据元素（这组存储单元可以是连续的，也可以是不连续的）。它不要求逻辑上相邻的元素在物理位置上也相邻。 
      随机存储最典型的代表为链式存储：
      1. 比顺序存储结构的存储密度小 （每个节点都由数据域和指针域组成，所以相同空间内假设全存满的话顺序比链式存储更多）。
      2. 逻辑上相邻的节点物理上不必相邻。
      3. 插入、删除灵活 （不必移动节点，只要改变节点中的指针）。
      4. 查找结点时链式存储要比顺序存储慢。
      5. 每个结点是由数据域和指针域组成。
2. 线性表的顺序存储方式
   
   优点：
   1. 使用数组作为内部容器简单且易用
   2. 在访问元素方面效率高
   3. 数组具有内存空间局部性的特点，由于本身定义为连续的内存块，所以任何元素与其相邻的元素在物理地址上也是相邻的。
   
   缺点：
   1. 内部数组大小是静态的，在使用前必须指定大小，如果遇到容量不足时，需动态拓展内部数组的大小，会造成额外的时间和空间开销
   2. 在内部创建数组时提供的是一块连续的空间块，当规模较大时可能会无法分配数组所需要的内存空间
   3. 顺序表的插入和删除是基于位置的操作，如果需要在数组中的指定位置插入或者删除元素，可能需要移动内部数组中的其他元素，这样会造成较大的时间开销，时间复杂度为O(n)   
                
3. 线性表的链式存储方式   
   1. 队列
      1. add()  往队列尾部插入元素,如果添加成功则返回true,超出队列界限的时候，add（）方法是抛出异常让你处理
      2. offer() 往队列尾部插入元素,如果添加成功则返回true,当超出队列界限的时候,offer（）方法是直接返回false
      3. remove() 从队列中删除第一个元素。如果队列元素为空，调用remove() 的行为与 Collection 接口的版本相似会抛出异常
      4. poll() 从队列中删除第一个元素。如果队列元素为空,新的 poll() 方法在用空集合调用时只是返回 null。
      5. element() 在队列的头部查询元素。如果队列为空，则抛出一个NoSuchElementException异常
      6. peek() 返回队列头部的元素,如果队列为空，则返回null
   2. 栈
      1. pop()  函数返回栈顶的元素，并且将该栈顶元素出栈。
      2. peek() 函数返回栈顶的元素，但不弹出该栈顶元素。 
      3. add()  继承自Vector的方法，且返回值类型是boolean。
      4. push() Stack自身的方法，返回值类型是参数类类型。
      
#### 算法思想 
1. 深度优先搜索（DFS），深度优先搜索策略又可以根据根节点、左孩子和右孩子的相对顺序被细分为前序遍历，中序遍历和后序遍历。
   1. 中序遍历方法: （1）递归 ； （2）栈(迭代)
   2. 先序遍历方法: （1）莫里斯遍历，算法的思路是从当前节点向下访问先序遍历的前驱节点，每个前驱节点都恰好被访问两次。首先从当前节点开始，向左孩子走一步然后沿着右孩子一直向下访问，直到到达一个叶子节点（当前节点的中序遍历前驱节点），所以我们更新输出并建立一条伪边 predecessor.right = root 更新这个前驱的下一个点。如果我们第二次访问到前驱节点，由于已经指向了当前节点，我们移除伪边并移动到下一个顶点。
                       如果第一步向左的移动不存在，就直接更新输出并向右移动。； （2）栈(迭代)，从根节点开始，每次迭代弹出当前栈顶元素，并将其孩子节点压入栈中，先压右孩子再压左孩子。

2. 宽度优先搜索（BFS） 
   层次遍历：（1）递归  （2）迭代（队列）
   
3. 二叉搜索树
   二叉搜索树的中序遍历是递增的        
      
                  
      
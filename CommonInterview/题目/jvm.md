####
https://blog.csdn.net/zy512638348/article/details/78174377

1. class加载过程
   系统加载 Class 类型的文件主要三步:加载->连接->初始化。连接过程又可分为三步:验证->准备->解析。
   
   1. 加载
      + 通过全类名获取定义此类的二进制字节流
      + 将字节流所代表的静态存储结构转换为方法区的运行时数据结构
      + 在内存中生成一个代表该类的 Class 对象,作为方法区这些数据的访问入口
     
   2. 连接
     + 验证
       + 文件格式验证
       
         验证字节流是否符合Class文件格式的规范，例如是否以0xCAFEBABE开头，主次版本号是否在当前虚拟机的处理范围之内，
         常量池中的常量是否有不支持的类型
         
       + 元数据验证
         
         对字节码描述的信息进行语义分析（对比javac编译阶段的语义分析）以保证其描述的信息符合java语言规范的要求，例如
         这个类是否有父类，除了java.lang.Object之外所有的类都有父类，这个类是否被继承了不允许继承的类（被final修饰的类）等
         
       + 字节码验证
          
         最复杂的一个阶段。通过数据流和控制流分析，确定程序语义是否是合法的，符合逻辑的。比如保证任意时刻操作数栈和
         指令代码序列都能配合工作
          
       + 符号引用验证
         
         确保解析动作能正确执行
     + 准备
       
       准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。该阶段有以下几点需要注意
       
       + 这时候进行内存分配的仅包括类变量(static)，而不包括实例变量，实例变量回在对象实例化时随着对象一块分配在Java堆中
       
       + 这里所设置的初始值"通常情况"下是数据类型默认的零值（如0、0L、null、false等），比如我们定义了public static int value=111 ，
         那么 value 变量在准备阶段的初始值就是 0 而不是111（初始化阶段才会复制）。特殊情况：比如给 value 变量加上了 fianl 关键字public 
         static final int value=111 ，那么准备阶段 value 的值就被复制为 111。
            
     + 解析
       
        解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行。
       
        符号引用就是一组符号来描述目标，可以是任何字面量。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。
        在程序实际运行时，只有符号引用是不够的，举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。
        当需要调用一个类的方法的时候，只要知道这个方法在方发表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。
       
        综上，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。
   
   
   3. 初始化
      
      初始化是类加载的最后一步，也是真正执行类中定义的 Java 程序代码(字节码)，初始化阶段是执行类构造器 <clinit> ()方法的过程。
      对于<clinit>（） 方法的调用，虚拟机会自己确保其在多线程环境中的安全性。因为 <clinit>（） 方法是带锁线程安全，所以在多线程环境下进行类初始化的话可能会引起死锁，并且这种死锁很难被发现。
      
      对于初始化阶段，虚拟机严格规范了有且只有5中情况下，必须对类进行初始化：
      
      + 当遇到 new 、 getstatic、putstatic或invokestatic 这4条直接码指令时，比如 new 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。
      + 使用 java.lang.reflect 包的方法对类进行反射调用时 ，如果类没初始化，需要触发其初始化。
      + 初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。
      + 当虚拟机启动时，用户需要定义一个要执行的主类 (包含 main 方法的那个类)，虚拟机会先初始化这个类。
      + 当使用 JDK1.7 的动态动态语言时，如果一个 MethodHandle 实例的最后解析结构为 REF_getStatic、REF_putStatic、REF_invokeStatic、的方法句柄，并且这个句柄没有初始化，则需要先触发器初始化。
      
2. java内存区域
   jdk1.8之前: （虚拟机栈，本地方法栈，程序计数器）这些是线程私有的   （ 堆内存，方法区(里面有常量池)   直接内存）这些是线程共享的
      
   jdk1.8之后：虚拟机栈，本地方法栈，程序计数器    堆内存       直接内存（元空间代替方法区）
   
   程序计数器： 是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。                                  
              另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。
   
   虚拟机栈：描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。Java 内存可以粗糙的区分为堆内存（Heap）和栈内存 (Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。 
            局部变量表主要存放了编译器可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。
   
   本地方法栈：而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。
         
   堆：Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。Java 堆是垃圾收集器管理的主要区域，因此也被称作GC 堆
   
   方法区：它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。
          JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。
          整个永久代有一个 JVM 本身设置固定大小上线，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，并且永远不会得到 java.lang.OutOfMemoryError。你可以使用 -XX：MaxMetaspaceSize 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。-XX：MetaspaceSize 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。
       
   常量池：运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用）   
          JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。
    
3. java内存模型
   
   Java内存模型定义了线程和内存之间关系：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读 / 写共享变量的副本。本地内存是 JMM 的一个抽象概念，并不真实存在；它涵盖内存、缓存、寄存器以及其他的硬件和编译器优化。
   
   java内存模型中规定,所有变量都存储在主内存中,主内存是共享内存区域,所有线程都可以访问,但线程对变量的操作,比如读取,赋值等必须在自己的工作内存中进行.
   
   对变量的操作步骤:
   
   首先,将变量从主内存拷贝到自己的工作内存中去;
   然后在自己的工作内存中对变量进行操作,操作完成后,再将变量写回主内存.
   
   JMM如何解决可见性问题？总的来说:就是把数据从内存加载到缓存,寄存器,然后运算结束再写回主内存.
  
   
   volatile的技术基石--内存屏障
   
   内存屏障是cpu指令，该指令保证特定操作的顺序性和某些内存的可见性。插入一条内存屏障指令之后会告诉编译器和CPU：不管什么指令都不能和这条指令重排序。内存屏障所做的另外一件事情就是强制刷出各种CPU cache，如一个Write-Barrier（写入屏障）将刷出所有在Barrier之前写入cache的数据，因此，任何CPU上的线程都能读取到这些数据的最新版本。 

4. happens-before 发生在此之前
   这是java对程序执行顺序制定的规则，实现同步必须遵循该规则。这样程序员只需要写出正确的同步程序，happens-before保证运行结果不会错。
   
   A happens-before B，不仅仅表示A在B之前执行，还意味着A的执行结果对B可见，这保证了可见性。
   
   A happens-before B，A也不一定要在B之前执行，如果AB交替，执行结果任然正确，则允许编译器、处理器进行优化重排序。所以只要程序结果正确，编译器、处理器怎么优化，怎么重排序都没问题，都是好的。    
   
   就是无法通过happens-before原则推导出来的,才能进行指令重排序
   
   如果两个操作不满足任何一个happends-before规则,那么这两个操作就没有顺序的保障,jvm可以对这两个操作进行重排序.
   
   如果操作A happends-before 操作B,那么操作A在内存上所做的操作对操作B都是可见的.   
   
   happens-before规则：
   1. 程序顺序规则：在一个线程中，前面的操作happens-before后面的操作
   2. 锁规则：对同一个锁，解锁happens-before加锁
   3. volatile域规则：写volatile变量，happens-before后面任意一个读这个volatile变量的操作
   4. 传递性：A happens-before B，B happens-before C，则A happens-before C
   5. start()规则：如果线程A执行ThreadB.start() 那么ThreadB.start() happens-before 线程B中任何操作
   6. join()规则：如果线程A执行ThreadB.join(),那么线程B中的所有操作happens-before ThreadB.join()

5. 双亲委派模型   
   JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自java.lang.ClassLoader：
   
   BootstrapClassLoader(启动类加载器) ：最顶层的加载类，由C++实现，负责加载 %JAVA_HOME%/lib目录下的jar包和类或者或被 -Xbootclasspath参数指定的路径中的所有类。
   ExtensionClassLoader(扩展类加载器) ：主要负责加载目录 %JRE_HOME%/lib/ext 目录下的jar包和类，或被 java.ext.dirs 系统变量所指定的路径下的jar包。
   AppClassLoader(应用程序类加载器) :面向我们用户的加载器，负责加载当前应用classpath下的所有jar包和类。
   
   每一个类都有一个对应它的类加载器。系统中的 ClassLoder 在协同工作的时候会默认使用 双亲委派模型 。即在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派该父类加载器的 loadClass() 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 BootstrapClassLoader 中。当父类加载器无法处理时，才由自己来处理。当父类加载器为null时，会使用启动类加载器 BootstrapClassLoader 作为父类加载器。
   
   AppClassLoader的父类加载器为ExtClassLoader ExtClassLoader的父类加载器为null，null并不代表ExtClassLoader没有父类加载器，而是 BootstrapClassLoader 。
   
   双亲委派模型保证了Java程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 java.lang.Object 类的话，那么程序运行的时候，系统就会出现多个不同的 Object 类。
   
8. 垃圾收集算法,cms & g1 ，新生代，老年代的回收策略区别
   
   1. 标记-清除算法
      该算法分为“标记”和“清除”阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它是最基础的收集算法。
      缺点：1. 效率问题  2. 空间问题（标记清除后会产生大量不连续的碎片）
   2. 复制算法
      为了解决效率问题，“复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。
   3. 标记-整理算法
      根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。
   4. 分代收集算法
      当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。
      
      比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。
   
   
   垃圾回收器：如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。
   
   CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。
   CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。
   用于对年老代进行回收，目标是尽量减少应用的暂停时间，减少full gc发生的机率，利用和应用程序线程并发的垃圾回收线程来标记清除年老代。CMS并非没有暂停，而是用两次短暂停来替代串行标记整理算法的长暂停。
   CMS 收集器是一种 “标记-清除”算法实现的：
   1. 初始标记： 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；
   2. 并发标记： 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
   3. 重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短
   4. 并发清除： 开启用户线程，同时 GC 线程开始对为标记的区域做清扫。
   
   从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：并发收集、低停顿。但是它有下面三个明显的缺点：
   1. 对 CPU 资源敏感；
   2. 无法处理浮动垃圾；
   3. 它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。
   
   G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.
   1. 并行与并发：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。
   2. 分代收集：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。
   3. 空间整合：与 CMS 的“标记--清理”算法不同，G1 从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。
   4. 可预测的停顿：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。
   
   G1 收集器的运作大致分为以下几个步骤：
   1. 初始标记
   2. 并发标记
   3. 最终标记
   4. 筛选回收
   G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 GF 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。
   
   基本思想是化整为零，将堆分为多个Region，优先收集回收价值最大的Region。
   并行并发
   分代收集
   空间整合（标记整理算法）
   可预测的停顿            

9. gc回收状态怎么查看
   
   jstat -gcutil 2388 3000 6  每隔3秒打印一次pid为2388的堆内存的使用情况，共打印6次。
   
   S0— Heap上的 Survivor space 0 区已使用空间的百分比     
   
   S1 — Heap上的 Survivor space 1 区已使用空间的百分比     
   
   E   — Heap上的 Eden space 区已使用空间的百分比    
   
   O   — Heap上的 Old space 区已使用空间的百分比     
   
   P   — Perm space 区已使用空间的百分比 
   
   YGC — 从应用程序启动到采样时发生 Young GC 的次数 
   
   YGCT– 从应用程序启动到采样时 Young GC 所用的时间(单位秒)     
   
   FGC — 从应用程序启动到采样时发生 Full GC 的次数 
   
   FGCT– 从应用程序启动到采样时 Full GC 所用的时间(单位秒)     
   
   GCT — 从应用程序启动到采样时用于垃圾回收的总时间(单位秒) 

10. 新生代为什么8:1:1，maxpermsize，useparalleloldgc参数
   
   新生代中的对象98%都是“朝生夕死”的（即：将被回收的对象：存活的对象 > 9：1），所以如果根据复制算法完成按照1：1的比例划分新生代的内存空间，将会造成相当大的浪费。
   
   JVM开发人员将新生代分为一块较大的Eden区，和两块较小的Survivor区，每次可以使用来存放对象的是Eden区和其中一块Survivor区。当回收时，将Eden区和Survivor from中还存活着的对象一次性复制到另一块Survivor to区（这里进行复制算法），然后就清空调Eden区和Survivor from区中的数据。

   复制算法所需要的担保内存 = 9：1，这样即使所有的对象都不会存活，那么也只会“浪费”10%的内存空间。不过我们也无法保证存活的对象一定<2%或10%，当新生代中Survivor to区内存不够用时，就会触发老年代的担保机制进行分配担保。
   
   之所以Eden区：Survivor from区是8：1，是因为JVM规定，两个Survivor区中from和to是相对的，根据每次进行MinorGC后哪个区被清空没有对象了，这个区就会成为to区，而通过复制算法复制的还存活下的对象所在的那个区，也就是有对象的区即为from（即from和to区会进行位置交换，所以在我们讲解新生代时，还会给这两个Survivor区加上S1和S2两个名称，而S1和S2位置则是固定的）
   
   新生代中的可用内存：复制算法用来担保的内存为9：1
   可用内存中Eden：S1区为8：1
   即新生代中Eden:S1:S2 = 8：1：1
   
11. GC Roots
    
    GC管理的主要区域是Java堆，一般情况下只针对堆进行垃圾回收。方法区、栈和本地方法区不被GC所管理,因而选择这些区域内的对象作为GC roots,被GC roots引用的对象不被GC回收。
    
    1. 虚拟机栈(栈帧中的本地变量表)中引用的对象
    2. 方法区中的类静态属性引用的对象
    3. 方法区中的常量引用的对象
    4. 原生方法栈（Native Method Stack）中 JNI 中引用的对象   
    
12. 引用    
    如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。
    1. 强引用
       以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。
       垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。
    2. 软引用
       如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。
    3. 弱引用
       被弱引用的关联的对象只能生存到下一次垃圾收集发生之前
       只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。
    4. 虚引用
       如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。
       虚引用主要用来跟踪对象被垃圾回收的活动。
       虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。

13. 对象死亡判断
    1. 引用计数器法，无法解决相互引用
    2. 可达性分析 GC Roots
    
    即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。
    
    被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。

14. 如何判断一个类是无用的类
    
    1. 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
    2. 加载该类的 ClassLoader 已经被回收。
    3. 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。   

15. 为什么要分代
    分代的唯一理由就是优化GC性能。你先想想，如果没有分代，那我们所有的对象都在一块，GC的时候我们要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而我们的很多对象都是朝生夕死的，如果分代的话，我们把新创建的对象放到某一地方，当GC的时候先把这块存“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。 
    
16. 手动gc 
    手动gc的缺点：
    1.程序员忘记去释放内存
    2.应用程序访问已经释放的内存
    
    System.gc();就是呼叫java虚拟机的垃圾回收器运行回收内存的垃圾。
    每个 Java 应用程序都有一个 Runtime 类实例，使应用程序能够与其运行的环境相连接。可以通过 getRuntime 方法获取当前运行时。 Runtime.getRuntime().gc();
    java.lang.System.gc()只是java.lang.Runtime.getRuntime().gc()的简写，两者的行为没有任何不同。
    这个命令只是建议JVM安排GC运行, 还有可能完全被拒绝。 GC本身是会周期性的自动运行的,由JVM决定运行的时机,而且现在的版本有多种更智能的模式可以选择,还会根据运行的机器自动去做选择,就算真的有性能上的需求,也应该去对GC的运行机制进行微调,而不是通过使用这个命令来实现性能的优化。

17. gc的演进

18. gc调优，开启gc日志，观察触发gc频率，gc前后差值，具体调优选项 
    
    GC监控方式可以分为CUI(命令行交互接口) 和 GUI(图形界面接口) 两种。
    典型的CUI GC监控方法包含了一个叫做 jstat 的独立CUI程序，或者在运行JVM时使用 verbosegc 选项。 
    GUI GC监控是通过独立的GUI程序来完成，使用最广泛的三种程序分别为：jsonsole、jvisualvm和Visual GC。
    
    jstat:
    jstat 位于$JDK_HOME/bin下，所以如果 java 或 javac 可以运行，那么 jstat也可以直接使用。
    -gcutil 用于检查堆区域内存使用情况，GC次数以及GC操作的总时间
    -gccapacity 和其他选项用于检查实际分配的内存大小
    
    -verbosegc
    -verbosegc 是在Java应用启动时指定的JVM选项。jstat 可以在不指定任何JVM参数的情况下使用，-verbosegc 需要在JVM启动时指定，因此这个选项可能认为没什么必要(因此可以使用jstat代替)。然而，当发生GC时 -verbosegc 展示的结果更加容易理解，对于监控GC操作也十分有用

19. gc常用算法的执行过程，stw两次标记
    我们知道垃圾回收首先是要经过标记的。对象被标记后就会根据不同的区域采用不同的收集方法。看上去很完美的一件事情，其实并不然。 
      大家有没有想过一件事情，当虚拟机完成两次标记后，便确认了可以回收的对象。但是，垃圾回收并不会阻塞我们程序的线程，他是与当前程序并发执行的。所以问题就出在这里，当GC线程标记好了一个对象的时候，此时我们程序的线程又将该对象重新加入了“关系网”中，当执行二次标记的时候，该对象也没有重写finalize()方法，因此回收的时候就会回收这个不该回收的对象。 
      虚拟机的解决方法就是在一些特定指令位置设置一些“安全点”，当程序运行到这些“安全点”的时候就会暂停所有当前运行的线程（Stop The World 所以叫STW），暂停后再找到“GC Roots”进行关系的组建，进而执行标记和清除。 
      这些特定的指令位置主要在：
    
    1、循环的末尾
    2、方法临返回前 / 调用方法的call指令后
    3、可能抛异常的位置

20. 线程死锁如何检查    

21. jvm调优   
    
    -XX:MetaspaceSize=128m （元空间默认大小）
    -XX:MaxMetaspaceSize=128m （元空间最大大小）
    -Xms1024m （堆最大大小）
    -Xmx1024m （堆默认大小）
    -Xmn256m （新生代大小）
    -Xss256k （棧最大深度大小）
    -XX:SurvivorRatio=8 （新生代分区比例 8:2）
    -XX:+UseConcMarkSweepGC （指定使用的垃圾收集器，这里使用CMS收集器）
    -XX:+PrintGCDetails （打印详细的GC日志）
    
    目前针对JVM的调优主要有两个方面：内存调优和垃圾回收策略调优。
    1. 内存调优  
       设置catalina.sh文件中JAVA_OPTS变量即可，因为后面的启动参数会把JAVA_OPTS作为JVM的启动参数来处理。
       1. -Xmx512m：设置Java虚拟机的堆的最大可用内存大小，单位：兆(m)，整个堆大小=年轻代大小 + 年老代大小 + 持久代大小。
       
          持久代一般固定大小为64m。堆的不同分布情况，对系统会产生一定的影响。尽可能将对象预留在新生代，减少老年代GC的次数（通常老年回收起来比较慢）。
       
          实际工作中，通常将堆的初始值和最大值设置相等，这样可以减少程序运行时进行的垃圾回收次数和空间扩展，从而提高程序性能。
       
       2. -Xms512m：设置Java虚拟机的堆的初始值内存大小，单位：兆(m)，此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。
  
       3. -Xmn170m：设置年轻代内存大小，单位：兆(m)，此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。一般在增大年轻代内存后，也会将会减小年老代大小。
       
       4. -Xss128k：设置每个线程的栈大小。JDK5.0以后每个线程栈大小为1M，以前每个线程栈大小为256K。更具应用的线程所需内存大小进行调整。
       
          在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。
       
       5. -XX:NewRatio=4：设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5 。
       
       6. -XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6。
       
       7. -XX:MaxPermSize=16m：设置持久代大小为16m，上面也说了，持久代一般固定的内存大小为64m。
       
       8. -XX:MaxTenuringThreshold=0：设置垃圾最大年龄。
       
          如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。
       
          如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。
    
22. tomcat调优
    1. URIEncoding=“UTF-8”：设置Tomcat的字符集。
    2. maxThreads=“300”：设置当前Tomcat的最大并发数。Tomcat默认配置的最大请求数是150个，即同时能支持150个并发。
    3. minSpareThreads=“50”：设置当前Tomcat初始化时创建的线程数，默认值为25。
    4. acceptCount=“250”：当同时连接的人数达到maxThreads参数设置的值时，还可以接收排队的连接数量，超过这个连接的则直接返回拒绝连接。指定当任何能够使用的处理请求的线程数都被使用时，能够放到处理队列中的请求数，超过这个数的请求将不予处理。默认值为100。
       在实际应用中，如果想加大Tomcat的并发数 ，应该同时加大acceptCount和maxThreads的值。  
    5. enableLookups=“false”：是否开启域名反查，一般设置为false来提高处理能力，它的取值还有true，一般很少使用。
    6. maxKeepAliveRequests=“1”：nginx动态的转给tomcat，nginx是不能keepalive的，而tomcat端默认开启了keepalive，会等待keepalive的timeout，默认不设置就是使用connectionTimeout。
    
       所以必须设置tomcat的超时时间，并关闭tomcat的keepalive。否则会产生大量tomcat的socket timewait。
    
       maxKeepAliveRequests=”1”就可以避免tomcat产生大量的TIME_WAIT连接，从而从一定程度上避免tomcat假死。     

    
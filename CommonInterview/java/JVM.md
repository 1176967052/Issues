##### 类加载过程
系统加载 Class 类型的文件主要三步:加载->连接->初始化。连接过程又可分为三步:验证->准备->解析。

1. 加载
   + 通过全类名获取定义此类的二进制字节流
   + 将字节流所代表的静态存储结构转换为方法区的运行时数据结构
   + 在内存中生成一个代表该类的 Class 对象,作为方法区这些数据的访问入口
  
2. 连接
  + 验证
    + 文件格式验证
    
      验证字节流是否符合Class文件格式的规范，例如是否以0xCAFEBABE开头，主次版本号是否在当前虚拟机的处理范围之内，
      常量池中的常量是否有不支持的类型
      
    + 元数据验证
      
      对字节码描述的信息进行语义分析（对比javac编译阶段的语义分析）以保证其描述的信息符合java语言规范的要求，例如
      这个类是否有父类，除了java.lang.Object之外所有的类都有父类，这个类是否被继承了不允许继承的类（被final修饰的类）等
      
    + 字节码验证
       
      最复杂的一个阶段。通过数据流和控制流分析，确定程序语义是否是合法的，符合逻辑的。比如保证任意时刻操作数栈和
      指令代码序列都能配合工作
       
    + 符号引用验证
      
      确保解析动作能正确执行
  + 准备
    
    准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。该阶段有以下几点需要注意
    
    + 这时候进行内存分配的仅包括类变量(static)，而不包括实例变量，实例变量回在对象实例化时随着对象一块分配在Java堆中
    
    + 这里所设置的初始值"通常情况"下是数据类型默认的零值（如0、0L、null、false等），比如我们定义了public static int value=111 ，
      那么 value 变量在准备阶段的初始值就是 0 而不是111（初始化阶段才会复制）。特殊情况：比如给 value 变量加上了 fianl 关键字public 
      static final int value=111 ，那么准备阶段 value 的值就被复制为 111。
         
  + 解析
    
     解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行。
    
     符号引用就是一组符号来描述目标，可以是任何字面量。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。
     在程序实际运行时，只有符号引用是不够的，举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。
     当需要调用一个类的方法的时候，只要知道这个方法在方发表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。
    
     综上，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。


3. 初始化
   
   初始化是类加载的最后一步，也是真正执行类中定义的 Java 程序代码(字节码)，初始化阶段是执行类构造器 <clinit> ()方法的过程。
   对于<clinit>（） 方法的调用，虚拟机会自己确保其在多线程环境中的安全性。因为 <clinit>（） 方法是带锁线程安全，所以在多线程环境下进行类初始化的话可能会引起死锁，并且这种死锁很难被发现。
   
   对于初始化阶段，虚拟机严格规范了有且只有5中情况下，必须对类进行初始化：
   
   + 当遇到 new 、 getstatic、putstatic或invokestatic 这4条直接码指令时，比如 new 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。
   + 使用 java.lang.reflect 包的方法对类进行反射调用时 ，如果类没初始化，需要触发其初始化。
   + 初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。
   + 当虚拟机启动时，用户需要定义一个要执行的主类 (包含 main 方法的那个类)，虚拟机会先初始化这个类。
   + 当使用 JDK1.7 的动态动态语言时，如果一个 MethodHandle 实例的最后解析结构为 REF_getStatic、REF_putStatic、REF_invokeStatic、的方法句柄，并且这个句柄没有初始化，则需要先触发器初始化。
   
4. java内存区域
   jdk1.8之前: （虚拟机栈，本地方法栈，程序计数器）这些是线程私有的   （ 堆内存，方法区(里面有常量池)   直接内存）这些是线程共享的
      
   jdk1.8之后：虚拟机栈，本地方法栈，程序计数器    堆内存       直接内存（元空间代替方法区）
   
   程序计数器： 是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。                                  
              另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。
   
   虚拟机栈：描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。Java 内存可以粗糙的区分为堆内存（Heap）和栈内存 (Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。 
            局部变量表主要存放了编译器可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。
   
   本地方法栈：而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。
         
   堆：Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。Java 堆是垃圾收集器管理的主要区域，因此也被称作GC 堆
   
   方法区：它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。
          JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。
          整个永久代有一个 JVM 本身设置固定大小上线，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，并且永远不会得到 java.lang.OutOfMemoryError。你可以使用 -XX：MaxMetaspaceSize 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。-XX：MetaspaceSize 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。
       
   常量池：运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用）   
          JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。

5. 对象创建过程
   
   1. 类加载检查         
   2. 内存分配，分配方式：指针碰撞和空闲列表  
      
      选择那种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。
      
      指针碰撞：
      
      适用场合：堆内存规整(没有内存碎片)的情况
      原理：将用过的内存全部整合到一边，没用过的内存放在另一半，中间有个分界指针，只需要向着没用过的内存方向将该指针移动内存代销的位置即可
      GC收集器：Serial,ParNew
      
      适用场合：堆内存不规整的情况
      原理：虚拟机维护一个列表，该列表中会记录哪些内存块是可用的。分配的时候，找一块足够大的内存块来划分给对象实例，然后更新列表即可
      GC收集器：CMS
      
      内存分配的并发问题：
      虚拟机采用两种方式保证线程安全：
      1. CAS+失败重试： CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。
      2. TLAB： 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配
   3. 初始化零值
   4. 设置对象头
   5. 执行init方法
6. 垃圾回收
    
   eden 区、s0("From") 区、s1("To") 区都属于新生代，tentired 区属于老年代。大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s1("To")，并且对象的年龄还会加 1(Eden 区->Survivor 区后对象的初始年龄变为 1)，
   当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。经过这次GC后，Eden区和"From"区已经被清空。这个时候，"From"和"To"会交换他们的角色，也就是新的"To"就是上次GC前的“From”，新的"From"就是上次GC前的"To"。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，"To"区被填满之后，会将所有对象移动到年老代中。      
          

   
   
   
   
       
    
     
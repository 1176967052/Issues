#### MySql:

1. MyISAM和InnoDB的对比与总结
   + count运算的区别
   + 是否支持事务和崩溃后的安全修复
   + 是否支持外键  
  *总结：MyISAM适合没有事务且读密集的表，InnoDB适合有事务支持且写密集的表*
2. 数据库索引
     + 为什么使用索引
        + 创建唯一索引，保证数据库中每行数据的唯一性
        + 大大加快检索速度（大大减少检索的数据量），是主要原因
        + 帮助服务器避免排序和临时表
        + 将随机IO变为顺序IO
        + 加速表与表之间的连接
     + 索引优点这么多，为什么不对表中每列创建一个索引
        + 表中数据增，删，改的时候，要动态维护索引，降低了数据维护速度
        + 索引需要占用物理空间
        + 创建和维护索引需要耗费时间，而且时间随数据量的增加而增加
     + 索引如何提高查询速度
     
         将无序的数据变成相对有序的数据，就像查询目录一样
         
     + 使用索引注意事项
        + 在经常需要搜索的列上使用
        + 在经常使用的where子句中的列上创建索引，加快条件的判断速度
        + 在经常需要排序的列上创建索引，因为索引已经排
        + 在经常用在连接的列上，这些列主要是一些外键，可以加快连接速度
        + 对中，大型表创建索引很有效，但是特大型表维护开销很大，不适合建索引
        + 避免where子句中对字段施加函数，造成无法命中索引
        + 在使用InnoDB时使用与业务无关的自增主键昨晚主键，即使用逻辑主键，而不使用业务主键
        + 将打算加索引的列设置为not null，否则将导致引擎放弃使用索引而全表扫描
        + 删除长期未使用的索引（查询sys库的chema_unused_indexes视图来查询哪些索引从未被使用）
        + 在使用limit offset查询缓慢时，可借助索引
     + 索引的两种数据结构
        + 哈希索引 ：底层是哈希表，绝大多数是单条记录查询可以使用，查询性能最快，其他建议BTree索引
        + BTree索引：底层是B+树，但两种存储引擎实现方式不一样
     + MyISAM和InnoDB实现BTree索引方式的区别
      
     + 覆盖索引
     
3. 为什么索引能提高查询速度
   + mysql的基本存储结构是页（记录都存在页里）
   + 各个数据页组成一个双向链表
   + 每个数据页中的记录又可以组成一个单向链表
   
    每个数据页都会为存储在它里边儿的记录生成一个页目录，在通过主键查找某条记录的时候可以在页目录 中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录 以其他列(非主键)作为搜索条件:只能从最小记录开始依次遍历单链表中的每条记录。
所以说，如果我们写select * from user where indexname = 'xxx'这样没有进行任何优化的sql语句，默认会这样 做:
   1. 定位到记录所在的页:需要遍历双向链表，找到所在的页
   2. 从所在的页内中查找相应的记录:由于不是根据主键查询，只能遍历所在页的单链表了
   
   很明显，在数据量很大的情况下这样查找会很慢!这样的时间复杂度为O(n)。 使用索引之后 索引做了些什么可以让我们查询加快速度呢?其实就是将无序的数据变成有序(相对):
很明显的是:没有用索引我们是需要遍历双向链表来定位对应的页，现在通过 “目录” 就可以很快地定位到对应的页 上了!(二分查找，时间复杂度近似为O(logn))

4. 最左前缀原则

   MySQL中的索引可以以一定顺序引用多列，这种索引叫作联合索引。如User表的name和city加联合索引就是 (name,city)o而最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以 被用到。如下:
   1. select * from user where name=xx and city=xx ; //可以命中索引 
   2. select * from user where name=xx ; // 可以命中索引
   3. select * from user where city=xx; // 无法命中索引

   这里需要注意的是，查询的时候如果两个条件都用上了，但是顺序不同，如 city= xx and name =xx ，那么现在 的查询引擎会自动优化为匹配联合索引的顺序，这样是能够命中索引的.
由于最左前缀原则，在创建联合索引时，索引字段的顺序需要考虑字段值去重之后的个数，较多的放前面。 ORDERBY子句也遵循此规则。
注意避免冗余索引

   冗余索引指的是索引的功能相同，能够命中 就肯定能命中 ，那么 就是冗余索引如(name,city )和(name )这两 个索引就是冗余索引，能够命中后者的查询肯定是能够命中前者的 在大多数情况下，都应该尽量扩展已有的索引而 不是创建新索引。
MySQLS.7 版本后，可以通过查询 sys 库的 schemal_r dundant_indexes 表来查看冗余索引

5. 大表优化手段
   + 限定数据的范围（条件范围查询）
   + 读写分离，主库负责写，从库负责读
   + 垂直拆分表 
     + 优点：可以使得行数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简 化表的结构，易于维护。
     + 缺点：主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过 在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂
   + 水平拆分表，最好分库 
     + 优点：保持数据结构不变，进行数据分片，达到分布式目的，可以支撑非常大的数据量，应用端改造也少
     + 缺点：分片事务难以解决，跨节点join性能较差，逻辑复杂，增加逻辑，部署，运维的各种复杂度
     
     常见的数据库分片方案：
     
        + 客户端代理: 分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。 当当网的 Sharding- JDBC 、阿里的TDDL是两种比较常用的实现。
        + 中间件代理: 在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。 我们现在谈的 Mycat 、360的Atlas、网易的DDB等等都是这种架构的实现。
        
     分库分表后id主键的生成策略:
     
        + 对外提供服务的算法：使用snowflake算法：时间戳+机房号+机器号+序列号
        + 客户端生成的算法： mongodb的ObjectId生成算法：Unix时间戳+机器号+进程号+随机数。无锁，使用CAS来保证数据不重复。
           
6. 重复记录删除只保留一条？

7. MVCC多版本并发控制

   MVCC主要适用于mysql的RC，RR隔离级别，是乐观锁的一种实现。MySQL默认隔离级别是RR
   
   
8. 如何实现数据查询时加锁

9. 事务的隔离级别

10. ACID

11. 幻读、脏读、不可重复读

12. sql语句的常见优化策略

13. 数据库三大范式
































       
















[详细内容查阅](https://www.cnblogs.com/geek6/p/3951677.html)
#### 设计模式六大原则
##### 总原则：开闭原则

   开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。

1. 单一职责原则

   不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，如若不然，就应该把类拆分。
   
2. 里氏替换原则LSP
   
   任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。
   
3. 依赖倒转原则
   
   面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。
   
4. 接口隔离原则

   每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。
   
5. 最少知道原则

   一个类对自己依赖的类知道的越少越好。也就是说无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。
   
6. 合成复用原则 
   
   原则是尽量首先使用合成/聚合的方式，而不是使用继承。

#### 常见设计模式

1. 单例模式

   单例对象能保证在一个JVM中，该对象只有一个实例存在。有四种实现方式：
  + 饿汉模式：“因为饿，所以要立即吃饭，刻不容缓”，在定义类的静态私有变量同时进行实例化。第一次用到这个类的时候就加载
   
     ```
       public class Singleton {
         private static final Singleton singleton = new Singleton();
         private Singleton() {
         }
         public static Singleton getInstance() {
             return singleton;
         }
       } 
     ```
     ①声明静态私有类变量，且立即实例化，保证实例化一次
     
     ②私有构造，防止外部实例化（通过反射是可以实例化的，不考虑此种情况）
     
     ③提供public的getInstance（）方法供外部获取单例实例
     
     好处：线程安全；获取实例速度快 缺点：类加载即初始化实例，内存浪费
     
  + 懒汉模式：“这个人比较懒，等用着你的时候才去实例化”，延迟加载。第一次使用getInstance()方法才加载
    
    ```
      public class Singleton {
        private static Singleton singleton = null;
        private Singleton() {
        }
        public static Singleton getInstance() {
          if (singleton == null) {
            singleton = new Singleton();
          }
        return singleton;
        }
      }
    ```
    优点：在获取实例的方法中，进行实例的初始化，节省系统资源
   
    缺点：
   
    ①如果获取实例时，初始化工作较多，加载速度会变慢，影响系统系能
   
    ② 每次获取实例都要进行非空检查，系统开销大
   
    ③非线程安全，当多个线程同时访问getInstance()时，可能会产生多个实例
   
    接下来对它进行线程安全改造：
   
    同步锁
    ```
      public synchronized static Singleton getInstance() {
      if (singleton == null) {
      singleton = new Singleton();
      }
      return singleton;
      }
    ```
     优点：线程安全
     
     缺点：每次获取实例都要加锁，耗费资源，其实只要实例已经生成，以后获取就不需要再锁了
   
    双重检查锁
    ```
      public static Singleton getInstance() {  
      if (singleton == null) {
      synchronized (Singleton.class) {
        if (singleton == null) {
          singleton = new Singleton();
          } 
        }
      }
      return singleton;
      }
    ```
    + 优点：线程安全，进行双重检查，保证只在实例未初始化前进行同步，效率高 
    + 缺点：还是实例非空判断，耗费一定资源
     
  + 静态内部类 
    ```
       public class Singleton {
       private Singleton() {
       }
       private static class SingletonHolder {
         private static final Singleton singleton = new Singleton();
       }
       public static Singleton getInstance() {
         return SingletonHolder.singleton;
       }
       }
    ```
    优点：既避免了同步带来的性能损耗，又能够延迟加载 
     
  + 枚举
    ```
       public enum Singleton {
           INSTANCE;
       public void init() {
       System.out.println("资源初始化。。。");
       }
       }
    ``` 
    天然线程安全，可防止反射生成实例。
   
  
2. 代理模式
   
   由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。

   代理模式的主要优点有：
   + 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；
   + 代理对象可以扩展目标对象的功能；
   + 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；

   其主要缺点是：
   + 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；
   + 增加了系统的复杂度；
   
3. 适配器模式

   适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式
   + 类的适配器模式
     
     有一个Source类，拥有一个方法，待适配，目标接口是Targetable，通过Adapter类，将Source的功能扩展到Targetable里 
   + 对象的适配器模式
   
     基本思路和类的适配器模式相同，只是将Adapter类作修改，这次不继承Source类，而是持有Source类的实例，以达到解决兼容性的问题。 
   + 接口的适配器模式
      
     有时我们写的一个接口中有多个抽象方法，当我们写该接口的实现类时，必须实现该接口的所有方法，这明显有时比较浪费，因为并不是所有的方法都是我们需要的，有时只需要某一些，此处为了解决这个问题，我们引入了接口的适配器模式，借助于一个抽象类，该抽象类实现了该接口，实现了所有的方法，而我们不和原始的接口打交道，只和该抽象类取得联系，所以我们写一个类，继承该抽象类，重写我们需要的方法就行。 
   
   总结一下三种适配器模式的应用场景：
   
   + 类的适配器模式：当希望将一个类转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可。
   
   + 对象的适配器模式：当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个Wrapper类，持有原类的一个实例，在Wrapper类的方法中，调用实例的方法就行。
   
   + 接口的适配器模式：当不希望实现一个接口中所有的方法时，可以创建一个抽象类Wrapper，实现所有方法，我们写别的类的时候，继承抽象类即可。          
   
4. 装饰模式
   
   装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例   